# Экскурс во frontend

## Начало: HTML, CSS, JS

Всё начиналось с простых сайтов на чистом HTML: одно полотно тегов, один файл стилей CSS и один скрипт на JS. Роутинг — через обычные ссылки `<a href="...">`, при каждом переходе страница полностью перезагружается.

Проблема дублирования кода начала возникать в первых соц. сетях, тогда это решили тем, что frontend отдавался бэкендом, например, многие старые сайты написаны на php, который подсовывает всё необходимое. ВКонтакте был изначально написан как раз на php.

Чем это плохо?

1. Если имеем какую-то интерактивность, то каждый раз перезагружаем сайт. Одно действие - один эндпоинт.
2. Код превращался в бесконечный спагетти.
3. Нет нормального роутинга (перехода по сайту)
4. В компонентах cms'ок лишь можно прокидывать данные с сервера, нет никаких жизненных циклов, состояний и т.п.

Можете покликать по вкладкам `index.html`, `styles.css` и `script.js`, чтобы увидеть, как выглядел код.

Итого: если это просто лендинг без состояний и изменений, то нет проблем всё так же использовать базовый подход. Но таких сайтов без хотя бы формы заявки и анимаций выплывания всего и вся с каждым годом всё меньше.

## Эпоха SPA: Революция React

Дальше пришли одностраничные приложения (SPA). Самый популярный инструмент для их создания — React. Так же были и Angular, vue, remix и уже много других.

Суть SPA в том, что весь HTML генерируется на стороне клиента (в браузере): сервер отдает почти пустую страницу, а JavaScript уже "рисует" весь интерфейс.

Благодаря этому, переходы между страницами происходят мгновенно, без перезагрузки. Появилась возможность делиться компонентами, делать куда более сложные библиотеки, графику и многое другое. Эту штуку придумали в facebook, собственно чем больше проект, тем нужнее компонентный подход. В соц. сетях это стало необходимым ведь на каждое открытие диалога и тп перезагружаться - минус вайб.

Вы можете переключаться между вкладками "Главная", "Клиенты" и "Код" — страница не перезагружается, контент меняется на лету. А если нажмете на "Клиенты", увидите главную проблему SPA — загрузку данных. Пока данные грузятся, пользователь видит пустую страницу или прелоадер. Это плохо и для пользователя, и для поисковых роботов.

## SSR: Лучшее из двух миров

Решение проблемы SPA — это Server-Side Rendering (SSR), или рендеринг на сервере.
Здесь наглядно показан процесс:

1.  Браузер запрашивает страницу.
2.  Сервер получает данные, генерирует готовый HTML.
3.  Сервер отдает браузеру уже полностью сверстанную страницу. Пользователь моментально видит контент.
4.  Затем на клиенте запускается JavaScript и "оживляет" статичную страницу, добавляя интерактивность (этот процесс называется гидратация).

## Next.js: Стандарт индустрии

В многих компаниях настраивают SSR вручную, но сообщество придумало Next.js — самое популярное и поддерживаемое решение в экосистеме React. Он берет на себя всю сложную работу с SSR и дает кучу полезного из коробки.

Он много всего делает "под капотом" — от файлового роутинга и оптимизации изображений до серверных компонентов (RSC), которые кардинально уменьшают размер клиентского JavaScript.

## Frontend — это не только про данные

Современный фронтенд — это не только про  данные и SEO, но и про впечатления.

- **Анимации**: С помощью библиотек мы можем добавлять плавные и производительные анимации.
- **3D-графика**: C Three.js (слайд "Three.js") — интегрировать интерактивную 3D-графику прямо на сайт.

- **Ограничения**: Но даже с такими мощными инструментами мы всегда работаем в рамках браузера с его ограничениями безопасности. Чтобы лучше понять, что можно, а что нельзя делать на фронтенде, **попробуйте пройти небольшой интерактивный квиз на шестом слайде.**

Все подобные ограничения в основном связаны с тем, что в браузере нам не выделены видеокарты компьютеров, 5мб памяти для сохранения данных между заходами, данные хранятся открыто.

## Качество и стабильность: Тестирование

Чтобы код работал как часы и не ломался от изменений, мы пишем тесты.

- **На слайде "Тестирование"** я рассказываю про два типа: E2E (тестирование полных пользовательских сценариев) и Скриншотные (поиск визуальных багов).
- **На слайде "Код тестов"** можно увидеть, как они выглядят в коде, и даже "запустить" их в симуляторе VS Code.
- **А на слайде "Screenshot Tests"** есть интерактивный слайдер, который наглядно показывает, как тест находит визуальные отличия между эталонной версткой и текущей.

## Архитектура и удобство разработки

Чтобы проект был поддерживаемым и масштабируемым, важны архитектура и правильные инструменты.

- **Архитектура**: Мы делим код на логические слои (слайд "Архитектура проекта"), что делает его понятным и предсказуемым.
- **UI-Kit**: Чтобы не изобретать велосипед, мы используем UI-киты — наборы готовых компонентов. На слайде "UI-Kit" перечислены их преимущества, а на "UI Компоненты" можно вживую потыкать в кнопки и инпуты.
- **State Management**: Для управления состоянием приложения важно разделять серверные данные (кэширование, запросы) и клиентские (UI). **На слайде "State Management"** я сделал интерактивную демонстрацию реактивности.
- **Кастомные решения**: Иногда для специфических задач мы пишем свои "библиотеки" (слайд "Свои пакеты"), чтобы упростить разработку и избавиться от шаблонного кода.

## Взаимодействие с внешним миром: SEO и Backend

Фронтенд не живет в вакууме. Он постоянно общается с сервером и поисковыми системами.

- **SEO**: Это целый комплекс мер для улучшения позиций в поисковой выдаче. **На слайде "SEO"** я собрал основные технические аспекты: от мета-тегов до `JSON-LD`. Также для SEO важна практика выноса состояния фильтров в URL (слайд "URL для фильтров").
- **Backend**: Для безопасной авторизации мы используем `httpOnly` cookies (слайд "API & Данные"). А для самих операций с данными (создать, прочитать, обновить, удалить) используются стандартные HTTP-методы, о которых я рассказываю на **интерактивном слайде "HTTP Методы"**.
